# Procedural Circuits

Short overview: Procedural circuits are blocks generated by code at place-time from parameters. They build an internal subgraph (blocks + wires) and expose inputs/outputs you can connect like any other block. They are identified by a stable UUID and a display name.

---

## For users

- Where to find: In the palette under `Procedural Circuits/<name>`.
- Parameters: Each procedural block may have parameters (e.g., size, depth, minimum pulse width, etc...). Edit them in the properties panel; a block is generated once you press "Create".
- Place & wire: Drop the block onto the grid and wire its inputs/outputs like normal blocks.
- Naming: Instances are auto-renamed to include their parameters (e.g., "Adder ("size": 4)").
- Composition: Some procedural blocks include other procedural blocks; this happens transparently.
- Recursion: Procedural circuits can include recursive structures, allowing for more complex designs.

Notes

- Changing a procedural circuit's defaults will refresh all of its existing instances in the project.
- Ports appear at fixed positions on the block; these are defined by the circuit author and cannot be moved by users, unless source code is modified.

---

## For procedural circuit developers

This section documents the implementation and authoring API for procedural circuits.

### Concept and runtime

- Core types live under `src/backend/proceduralCircuits/`:
  - `ProceduralCircuit`: abstract base for any procedural circuit.
  - `WasmProceduralCircuit`: concrete implementation that runs a WebAssembly module exported by the circuit author.
  - `GeneratedCircuit`: in-memory structure collecting blocks, connections, size, name.
  - `ProceduralCircuitManager`: registers/looks up procedural circuits (by path/UUID) and updates path mappings; parameter-set caching is handled inside `ProceduralCircuit`.

- Workflow
  - A module is registered (e.g., as `WasmProceduralCircuit`).
  - When a block instance is created or parameters change, the engine constructs a `GeneratedCircuit` by calling `makeCircuit(params, generatedCircuit)`.
  - The result is validated then applied to the existing block (`CircuitManager::createNewCircuit` / `updateExistingCircuit`).
  - Instances are cached per parameter set; defaults changes trigger `regenerateAll()` across instances.

### Authoring API (WASM)

Author procedural circuits as a tiny C/C++ module compiled to WebAssembly that exposes metadata and a `generateCircuit()` entrypoint and uses imported helpers. See `CircuitLib/procedural/functions.h`.

Required exports (C linkage)

- `const char* getUUID()`: returns a globally unique stable identifier. Keep this constant over time.
- `const char* getName()`: user-facing name visible in the UI.
- `const char* getDefaultParameters()`: parameter defaults in a simple key:value string map, e.g. `("size": 4)` (optional).
- `bool generateCircuit()`: builds the circuit and returns true on success, false on error.

Note: If you include `CircuitLib/procedural/functions.h` and define `const char* UUID`, `const char* name`, and (optionally) `const char* defaultParameters`, the headerâ€™s `exportedVar` macro will generate the `getUUID()`, `getName()`, and `getDefaultParameters()` functions with the correct exports. Wrap your definitions in `extern "C" { ... }` to avoid C++ name mangling.

Available imports (from `functions.h`)

- Parameters and logging
  - `int getParameter(const char* key)`: get integer parameter by key (merged with defaults).
  - `void logInfo(const char* msg)`, `void logError(const char* msg)`.
- Types
  - `BlockType getPrimitiveType(const char* primitiveName)`: primitives like "AND", "XOR", "SWITCH", "LIGHT", etc.
  - `BlockType getNonPrimitiveType(const char* UUID)`: get an existing non-primitive type by UUID.
  - `BlockType getProceduralCircuitType(const char* UUID, const char* parameters)`: get a procedural circuit type; parameters use the same string-encoding as defaults, e.g. `("size": 2)`.
- Building blocks and wiring
  - `block_id_t createBlock(BlockType type)`
  - `block_id_t createBlockAtPosition(cord_t x, cord_t y, Rotation r, BlockType type)`
  - `void createConnection(block_id_t outBlock, int outPort, block_id_t inBlock, int inPort)`
  - `void addConnectionInput(cord_t portX, cord_t portY, block_id_t internalBlock, connection_end_id_t internalPort)`
  - `void addConnectionOutput(cord_t portX, cord_t portY, block_id_t internalBlock, connection_end_id_t internalPort)`
  - `void setSize(cord_t width, cord_t height)`
- File composition
  - `unsigned int importFile(const char* filePath)`: load other modules (e.g., a sibling `.wasm`) before calling `getProceduralCircuitType` or `getNonPrimitiveType`. Used to specify dependencies between circuits.

Generation contract

- Call `setSize(width, height)` to define the outer block size early; changing it invalidates the layout. If ports or blocks extend beyond the set size, the validator will automatically expand the size to fit them.
- Create internal primitives or sub-circuits via `createBlock(...)`/`createBlockAtPosition(...)`.
- Expose external IO using `addConnectionInput`/`addConnectionOutput` by mapping a port grid coordinate (portX, portY) to an internal block's port.
  - Convention used by examples: inputs at x=0 (left edge), outputs at x=width-1 (right edge); y is the port row. This is a visual convention only; the engine accepts any coordinates within the defined size.
- Wire internals with `createConnection` (from an internal block's output port to another block's input port).
- Return `false` from `generateCircuit()` on parameter errors and emit `logError` with a helpful message. Note: the engine currently ignores the boolean return value; rely on emitting errors and producing a valid/invalid graph. Invalid graphs will be rejected by validation.

Parameters

- The engine merges per-instance parameters over `defaultParameters` before generation (done in `ProceduralCircuit::getCircuitId`; `regenerateAll()` re-applies the merge when defaults change).
- Current parameter type is integer by key (via `getParameter`). Use defensive checks for ranges; examples reject values < 1.

Composition and recursion

- You can import and instantiate other procedural circuits from within `generateCircuit()` using `importFile` + `getProceduralCircuitType`. The runtime is re-entrant; nested calls restore internal counters between invocations, i.e. there is no persistence between calls.

Lifecycle and caching

- Instances are cached by the full parameter set; repeat generations with identical parameters reuse the same block type.
- Changing `defaultParameters` at runtime triggers regeneration of all instances of that UUID.

Validation and errors

- After you build the `GeneratedCircuit`, the engine validates blocks, size, and connections; invalid graphs won't be applied.

Build notes

- Compile your C/C++ to WebAssembly using `buildWasm.py`.
- Keep the C symbol names (`UUID`, `name`, `defaultParameters`, `generateCircuit`). Link them without mangling (use `extern "C"`).
- The imported functions are under module name `env` (see attributes in `functions.h`). Preserve these when compiling.
- See existing examples in `CircuitLib/procedural/` (e.g., `andGate.cpp`, `adder.cpp`, `edgeDetector.cpp`).

### Engine classes (reference)

- `ProceduralCircuit` (C++)
  - `getCircuitId(params)`, `getBlockType(params)`: look up or create an instance for a given parameter set.
  - `setParameterDefaults(...)`: update defaults and regenerate all.
  - `makeCircuit(params, GeneratedCircuit&)` (virtual): implemented by `WasmProceduralCircuit` to call into WASM `generateCircuit`.
- `WasmProceduralCircuit::WasmInstance`
  - Loads a WASM module, reads metadata (`UUID`, `name`, defaults), and invokes `generateCircuit` while wiring imports to a `GeneratedCircuit` builder.
- `GeneratedCircuit`
  - Holds blocks, connections, size, name; exposes `getBlocks()`/`getConns()`; marked custom when authored procedurally.
- `ProceduralCircuitManager`
  - Creates/registers procedural circuits, looks them up by path/UUID, updates path mapping on rename.
